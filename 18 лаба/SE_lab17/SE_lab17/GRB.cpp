#include "GRB.h"
#include"Rules_GRB.h"
#include "string.h"

namespace GRB
{
	Rule::Chain::Chain(short psize, GRBALPHABET s, ...)//Структура: представление цепочки – правой стороны правила.
	{
		// Выделяем память для nt с размером psize и присваиваем этот размер size.
		this->nt = new GRBALPHABET[this->size = psize];
		// Преобразуем переменную s в указатель на int (небезопасное преобразование).
		int* ptr = (int*)&s;
		// Заполняем массив nt элементами из ptr (int-представления переменной s).
		for (int i = 0; i < psize; i++)
			this->nt[i] = (short)ptr[i];
	}


	Rule::Rule(GRBALPHABET pnn, int iderroe, short psize, Chain c, ...)//Создание экземпляра структуры
	{
		// Присваиваем значения полям объекта Rule из аргументов конструктора.
		this->nn = pnn;
		this->iderror = iderroe;
		// Выделяем память для массива chains с размером psize и присваиваем этот размер size.
		this->chains = new Chain[this->size = psize];
		// Присваиваем указатель на объект Chain c указателю ptr.
		Chain* ptr = &c;
		// Копируем данные из указателя ptr в массив chains.
		for (int i = 0; i < psize; i++)
			this->chains[i] = ptr[i];
	}

	//начальный символ (нетерминал) грамматики,символ дна стека (терминал),размер массива правил rules, который будет выделен,первое правило
	Greibach::Greibach(GRBALPHABET pstartN, GRBALPHABET pstbottomT, short psize, Rule r, ...)
	{
		// Присваиваем значения полям объекта Greibach из аргументов конструктора.
		this->startN = pstartN; // Устанавливаем начальный символ (нетерминал).
		this->stbottomT = pstbottomT; // Устанавливаем символ дна стека (терминал).
		// Выделяем память для массива rules с размером psize и присваиваем этот размер size.
		this->rules = new Rule[this->size = psize];
		// Присваиваем указатель на объект Rule r указателю ptr.
		Rule* ptr = &r;
		// Копируем данные из указателя ptr в массив rules.
		for (int i = 0; i < psize; i++)
			rules[i] = ptr[i];
	}


	short Greibach::getRule(GRBALPHABET pnn, Rule& prule)//метод для поиска правила в массиве
	{
		short rc = -1; // Инициализируем переменную rc значением -1 (по умолчанию).
		short k = 0; // Инициализируем переменную k значением 0.
		// Начинаем цикл, который будет выполняться до тех пор, пока k меньше размера массива rules
		// и пока rules[k].nn не равно переданному в аргументе pnn значению.
		while (k < this->size && rules[k].nn != pnn)
		{
			k++; // Увеличиваем k на 1, чтобы перейти к следующему элементу массива rules.
		}
		// После завершения цикла проверяем условие k < this->size.
		if (k < this->size)
		{
			// Если условие выполняется, это означает, что правило с nn равным pnn было найдено в массиве rules.
			// Мы присваиваем правило, найденное в массиве rules[rc], переменной prule.
			// Затем мы также устанавливаем значение rc равным k (индекс найденного правила).
			prule = rules[k];
			rc = k;
		}
		return rc; // Возвращаем индекс найденного правила в массиве rules, или -1, если правило не было найдено.

	}
	Rule Greibach::getRule(short n)//возвращает правило с индексом n из массива rules
	{
		Rule rc; // Создаем объект Rule с именем rc.
		// Проверяем, что значение n меньше размера массива rules (this->size).
		// Если условие выполняется, это означает, что существует правило с индексом n в массиве rules.
		if (n < this->size)
		{
			// Присваиваем объекту rc значение правила, находящегося в массиве rules по индексу n.
			rc = rules[n];
		}
		// Если условие не выполняется, останется значение rc по умолчанию, которое будет пустым правилом.
		// В конце метода возвращаем объект rc, содержащий правило, найденное по индексу n (или пустое правило, если n было недопустимым).
		return rc;
	}
	char* Rule::getCRule(char* b, short nchain)//формирования строкового представления правил
	{
		char buf[200]; // Создаем временный буфер для хранения цепочки.
		// Записываем в b первый символ, представляющий nn (некий идентификатор), затем знак "→".
		b[0] = Chain::alphabet_to_char(this->nn);
		b[1] = '-';
		b[2] = '>';
		b[3] = 0x00; // Устанавливаем нулевой символ в четвертом байте для завершения строки.
		// Вызываем метод `getCChain` объекта `Chain` внутри данного правила с индексом `nchain`.
		// Этот метод копирует содержимое цепочки в буфер `buf`.
		this->chains[nchain].getCChain(buf);
		// Используем функцию `strcat_s` для конкатенации буфера `buf` с буфером `b`.
		// `sizeof(buf) + 5` - вычисление размера буфера для правильного конкатенации.
		strcat_s(b, sizeof(buf) + 5, buf);
		return b; // Возвращаем указатель на буфер `b`, содержащий строку представления правила.
	}


	short Rule::getNextChain(GRBALPHABET t, Rule::Chain& pchain, short j)//поиск цепочки в массиве,где первый элемент равен значению t, переданному в аргументе.
	{
		short rc = -1; // Инициализируем переменную rc значением -1.
		// Начинаем цикл, который будет выполняться до тех пор, пока j меньше размера массива chains
		// и пока первый элемент массива nt в chains[j] не равен значению t, переданному в аргументе.
		while (j < this->size && this->chains[j].nt[0] != t)
		{
			j++; // Увеличиваем j на 1, чтобы перейти к следующему элементу массива chains.
		}
		// После завершения цикла проверяем условие j < this->size.
		if (j < this->size)
		{
			// Если условие выполняется, это означает, что цепочка с первым элементом nt[0] равным t была найдена.
			// Мы присваиваем цепочку, найденную в массиве chains[rc], переменной pchain.
			pchain = chains[j];
			rc = j; // Устанавливаем rc равным j, что указывает на индекс найденной цепочки.
		}
		// В конце метода возвращаем rc, который будет равен индексу найденной цепочки в массиве chains (или -1, если цепочка не была найдена).
		return rc;
	}

	char* Rule::Chain::getCChain(char* b)//позволяет получить строку-цепочку в символьном виде для отображения
	{
		// Принимает один аргумент, char* b, который представляет собой буфер для хранения строки-цепочки.
		for (int i = 0; i < this->size; i++)
		{
			// В цикле проходим по элементам массива nt (нетерминалов) в текущей цепочке.
			// Chain::alphabet_to_char - статический метод, преобразующий элемент nt[i]
			// (который имеет тип GRBALPHABET и представляет символ) в соответствующий ASCII-символ.
			// Этот ASCII-символ затем записывается в буфер b.
			b[i] = Chain::alphabet_to_char(this->nt[i]);
		}
		// После цикла добавляем нулевой символ ('\0') в буфер b, чтобы завершить строку-цепочку.
		b[this->size] = '\0';
		// В конце метод возвращает указатель на буфер b, содержащий строку-цепочку.
		return b;
	}

	Greibach getGreibach()
	{
		return greibach; 
	}

}